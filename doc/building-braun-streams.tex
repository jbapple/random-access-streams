\documentclass{llncs}
%\usepackage{amsthm}
\usepackage{amssymb,amsmath,algorithmic,algorithm,verbatim,alltt}

\DeclareMathOperator{\oddFrom}{oddFromEven}
\DeclareMathOperator{\nil}{\langle\rangle}
%\DeclareMathOperator{\cons}{cons}
\DeclareMathOperator{\true}{true}
\DeclareMathOperator{\false}{false}
\DeclareMathOperator{\head}{head}
\DeclareMathOperator{\evens}{evens}
\DeclareMathOperator{\odds}{odds}
\DeclareMathOperator{\fmap}{fmap}
\DeclareMathOperator{\iter}{iterate}
\newcommand{\ord}[1]{\|#1\|}
\newcommand{\cons}[2]{#1:#2}
\DeclareMathOperator{\ev}{ev}
\DeclareMathOperator{\od}{od}
%\renewcommand{\algorithmiccomment}[1]{// #1}

\begin{comment}
\newtheorem{theorem}{Theorem}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{proposition}[theorem]{Proposition}

%\theoremstyle{definition}
\newtheorem{definition}{Definition}

\end{comment}

\begin{document}

\title{Building Braun streams efficiently}

\author{Jim Apple}

\institute{}

\maketitle

\section*{Abstract}

Braun trees are a functional data structure with logarithmic-time indexing, update, and deque operations.\cite{hoogerwoord}
They are mostly superseded by finger trees, which decrease to a constant the time required for deque operations.\cite{kaplan96purely,HinzePat}
The restrictive structural constraints that give Braun trees slower deque operations than finger trees make them well-suited for operations on infinite lists, or {\em streams}.

This paper presents two new algorithms for building Braun streams from lazy lists.
The first algorithm builds a Braun stream from a linear stream; previous algorithms to build Braun trees either require superlinear time or terminate only for finite lists.\cite{okasakiBraun} 
The second algorithm builds a cyclic Braun stream from a possibly finite list. 
When applied to finite lists of length $n$, this algorithm generates Braun streams that use $O(n^2)$ space, even when forced to arbitrary depth.
In contrast, circular streams represented with finger trees must use $\Omega(i)$ space when forced to depth $i$.

Correctness proofs of the two algorithms are presented along with formal verifications using the Coq proof assistant.

\section{Introduction}
\label{logspaceCycle}

Braun trees are a tightly-constrained functional data structure offering array and deque operations in logarithmic time.\cite{hoogerwoord,okasakiBraun} 
Modern data structures with looser constraints support constant-time deque operations, and perform better than Braun trees in practice.\cite{okasakiSkewLists}
These more permissive structures, however, make some operations unsafe when building infinite lists, or {\em streams}.

For example, a user constructing an infinite list in Haskell can write {\tt let bees = 'b' : bees} to construct a stream.
Because the cons operation on native Haskell lists does need to inspect its second argument, {\tt bees} is constructed without trouble.
An example of how this fails in a typical Braun tree replacement is shown in Figure~\ref{23consFail}.

\begin{figure}
\begin{alltt}
data Node a = N2 a a
            | N3 a a a
data Digit a = D1 a
             | D2 a a
             | D3 a a a
             | D4 a a a a
data TTT a = TTT (Digit a) (TTT (Node a))

cons :: a -> TTT a -> TTT a
cons p (TTT (D1 q)       ds) = TTT (D2 p q) ds
cons p (TTT (D2 q r)     ds) = TTT (D3 p q r) ds
cons p (TTT (D3 q r s)   ds) = TTT (D4 p q r s) ds
cons p (TTT (D4 q r s t) ds) = TTT (D2 p q) (cons (N3 r s t) ds)

dangerousBees :: TTT Char
dangerousBees = cons 'b' dangerousBees

stream :: a -> TTT a
stream x = TTT (D2 x x) (stream (N2 x x))

safeBees :: TTT Char
safeBees = stream 'b'
\end{alltt}
\caption{
A simplification of 2-3 finger trees for use as a stream \cite{HinzePat}. 
Use of {\tt cons} as in {\tt dangerousBees} produces $\bot$, but a stream like {\tt safeBees} can be created while avoiding {\tt cons}.
However, {\tt safeBees} uses $\Omega(\log i)$ space when forced to depth $i$.
}
\label{23consFail}
\label{23stream}
\end{figure}

Figure~\ref{23consFail} shows the datatype definition and cons operation for Hinze and Paterson's 2-3 finger trees \cite{HinzePat}.
In this representation, streams are linear lists of trees of increasing depth generated by nesting {\tt Node}s.
At the top of each tree is a {\tt Digit} containing one to four {\tt Node} trees.

The {\tt cons} operation, in order to produce the first {\tt Digit} in the stream, needs to know the first {\tt Digit} in the rest of the stream.
For streams like {\tt dangerousBees}, {\tt cons} must know the first {\tt Digit} in the stream in order to produce the first {\tt Digit} in the stream.
Because of this, {\tt dangerousBees} is actually undefined.

Though {\tt cons} is an unsafe operation, streams can still be built of 2-3 finger trees by avoiding {\tt cons}.
Figure~\ref{23stream} also shows {\tt safeBees}, which does not evaluate to $\bot$, unlike {\tt dangerousBees}.
On the other hand, it uses $\Omega(\log i)$ space when forced to depth $i$.

\begin{figure}
\begin{alltt}
data BS a = BS a (BS a) (BS a)

cons x \(\sim\)(BS h o e) = BS x (cons h e) o

eyes :: BS Char
eyes = cons 'i' eyes

smallEyes :: BS Char
smallEyes = 
  let ans = BS 'i' ans ans 
  in ans
\end{alltt}
\caption{
Braun streams along with their {\tt cons} operation.
The ``$\sim$'' before the pattern match in {\tt cons} is an {\em irrefutable pattern} -- a pattern which is matched lazily \cite{haskellReport}.
The {\tt cons} operation is safe, so the stream {\tt eyes} is not $\bot$.
The stream {\t smallEyes} only takes up $O(1)$ space.
}
\label{braunCons}
\label{braunShare}
\end{figure}

Figure~\ref{braunCons} illustrates that Braun streams are better suited for these cases.
First, {\tt cons} is safe.
The result of an application of {\tt cons} is guarenteed to have {\tt BS} as its top-level constructor.
The irrefutable pattern matching in the deinition of {\tt cons}, denoted by ``$\sim$'', ensures that the top-level constructor is pattern matched lazily.
The definition of {\tt cons} given is thus equivalent to:

\begin{alltt}
cons x y =
  BS x
     (case y of
        BS h _ e -> cons h e)
     (case y of
        BS _ o _ -> o)
\end{alltt}

Since {\tt cons} for Braun streams does not need to match the top-level constructor of its tail until its own top-level constructor is chosen, {\tt eyes} in Figure~\ref{braunCons} is well-formed.
Additionally, unlike {\tt safeBees} in Figure~\ref{23stream}, {\tt smallEyes} in Figure~\ref{braunShare} can reuse its representation in its subtrees to use only $O(1)$ space, even when forced to arbitrary depth.

Like 2-3 finger trees, other stream candidates offering $O(1)$ deque operations do not support safe {\tt cons} or constant-space construction of repeating streams. This includes:

\begin{itemize}
\item Skew binary random access lists, which offers $O(1)$ worst-case {\tt cons} \cite{okasakiSkewLists}
\item Edison's \verb|BinaryRandList|, which supports {\tt cons} in $O(\log n)$ worst case time and $O(1)$ expected time \cite{holtersThesis}
\item Segmented binary lists,ehich offers $O(1)$ worst case {\tt cons} \cite{okasakiThesis}
\end{itemize}

What does linear time mean on infinite streams?

\begin{comment}

\begin{figure}
\begin{alltt}
data Tree a = Leaf a
            | Node a (Tree a) (Tree a)
type RAL a = [(Int,Tree a)]
cons :: a -> RAL a -> RAL a
cons x xs@((size1,t1) : (size2,t2) : rest) =
    if size1 == size2
    then (1 + size1 + size2, Node x t1 t2) : rest
    else (1,Leaf x) : xs
cons x xs = (1,Leaf x) : xs
bees :: RAL Char
bees = (1,Leaf 'b') : fmap (more 'b') bees
    where 
      more :: a -> (Int,Tree a) -> (Int,Tree a)
      more v (n,t) = (1 + 2*n, Node v t t)
badbees :: RAL Char
badbees = cons 'b' badbees
\end{alltt}
\caption{The type of skew binary random access lists and the cons operation \cite{okasakiSkewLists}.
The stream {\tt badbees} shows that, even though {\tt }}
\label{consFail}
\label{infiniteSkew}
\end{figure}
Figure~\ref{consFail} shows the datatype definition and cons operation for Okasaki's skew binary random access lists \cite{okasakiSkewLists}.
In this representation, random access lists are linear lists containing perfectly balanced binary trees stored in order of increasing depth.
No two trees in the list are the same size unless they are the two smallest trees in the list, and no three trees in the list are ever the same size.
When the two smallest trees are the same size, the cons operation glues them together with the new head of the list.
Otherwise, it just appends the new head as a tree of size 1.
% \perp? doesn't terminate? has no WHNF?
In this implementation of random access lists, \verb|let bees = cons 'b' bees| produces $\bot$.
The cons operation must inspect the new tail before constructing the head.
On \verb|bees|, this is not a terminating operation.
Of course, \verb|bees| can be constructed if we avoid cons, as shown in Figure~\ref{infiniteSkew}.
Despite this work-around, cons is still an unsafe operation.
%TODO: is it the culprit? cons also inspects the *value* of the list
The culprit is the flexibility in the shape of the random access list.
If the shape were fixed, 
see if the list is of length $2$ or more before 
To achieve these constant-time bounds, however, skew lists and finger trees relax their structural constraints. 
This prevents some stream constructions from terminating. 
For instance, \verb|cons| pattern matches on its second argument to determine its top-level constructor, so \verb|let ones = cons 1 ones| can never produce a top-level constructor.
In addition, the complexity of the structural constraints on skew lists and finger trees increases the memory usage of certain streams.
For instance, the stream \verb|ones| mentioned above can be stored in a Braun stream such that arbitrary indices may be retrieved without allocating more than a constant amount of memory.
Finger trees and skew lists, on the other hand, will both allocate $O(\log i)$ memory when the $i$th element is retrieved.
\end{comment}

\section{Braun streams}

Braun streams are simply infinite full binary trees.
The $0$th element is stored in the root of the tree, while odd-indexed elements appear in the left subtree and even-indexed elements appear in the right.
The subtrees of a Braun tree are also Braun trees, after reindexing by order.
That is, the 0th entry of any subtree is at its root, and its 1st, 3rd, 5th, ... elements are in its left subtree, etc.

To make this recursive relation clear, we index Braun streams by finite lists of booleans.
The root element is indexed by the empty list.
The odd-indexed elements are indexed by lists that start with \verb|True|, the even-indexed elements by lists that start with \verb|False|.
There is an obvious bijection between finite lists of booleans and integers;
it is expressed in \verb|ord| and \verb|list| in Figure~\ref{basicCode}.

\begin{figure}
\begin{alltt}
data Stream a = Stream a (Stream a) (Stream a) 

bat :: Stream a -> [Bool] -> a
bat (Stream h _ _) [] = h
bat (Stream _ o _) (True:r) = bat o r
bat (Stream _ _ e) (False:r) = bat e r

ord :: [Bool] -> Integer
ord [] = 0
ord (True:r) = 1 + 2*(ord r)
ord (False:r) = 2 + 2*(ord r)

list :: Integer -> [Bool]
list 0 = []
list n = 
    case x `mod` 2 of
      | 1 -> False:(list ((x-1)`div`2))
      | 0 -> True:(list ((x-2)`div`2))

head :: Stream a -> a
head (Stream h _ _) = h

odds :: Stream a -> Stream a
odds (Stream _ o _) = o

evens :: Stream a -> Stream a
evens (Stream _ _ e) = e
\end{alltt}
\caption{The basic definitions of Braun streams with their ordering as written in Haskell.}
\label{basicCode}
\end{figure}

\section{Building Braun streams from linear streams}

The algorithm for building a Braun stream from a linear stream (along with supporting code) is displayed in Figure~\ref{iterateCode}.

\begin{figure}
\begin{alltt}
instance Functor Stream where
    fmap f (Stream p q r) = Stream (f p) (fmap f q) (fmap f r)

oddFromEven :: (a -> b) -> b -> Stream a -> Stream b
oddFromEven f x  \(\sim\)(Stream h od ev) =
    Stream x (oddFromEven f (f h) ev) (fmap f od)

iterate :: (a -> a) -> a -> Stream a
iterate f x =
    let ev = fmap f od
        od = oddFromEven f (f x) ev
    in
      Stream x od ev

data LStream a = Cons a (LStream a)

ltail :: LStream a -> LStream a
ltail (Cons _ xs) = xs

lhead :: LStream a -> a
lhead (Cons x _) = x

fromLStream :: LStream a -> Stream a
fromLStream s = fmap lhead (iterate ltail s)
\end{alltt}
\caption{The algorithm for building a Braun stream from a linear stream in Haskell}
\label{iterateCode}
\end{figure}

For the proofs, \verb|ord l| is written $\ord{l}$ and \verb|bat s l| is written $s@l$.

\begin{lemma}\label{oddFromLemma}
For any $f, b, x, e, k$
if
\begin{displaymath}
\forall j . \ord{j} < \ord{b} \implies e@j = f^{2^k\ord{j}+2^{k+1}-2}x
\end{displaymath}
then
\begin{displaymath}
(\oddFrom f\ (f^{2^k-1}x)\ e)@b = f^{2^k\ord{b}+2^k-1}x
\end{displaymath}
\end{lemma}
\begin{proof}
We prove this by structural induction on $b$. If $b = \nil$, then 
\begin{displaymath}
\begin{array}{rcl}
(\oddFrom f\ (f^{2^k-1}x)\ e)@b & = & (\oddFrom f\ (f^{2^k-1}x)\ e)@\nil \\
& = & f^{2^k-1}x \\
& = & f^{0+2^k-1}x \\
& = & f^{2^k\ord{\nil}+2^k-1}x \\
& = & f^{2^k\ord{b}+2^k-1}x
\end{array}
\end{displaymath}

If $b = \cons{\true}{d}$,
\begin{displaymath}
\begin{array}{rcl}
(\oddFrom f\ (f^{2^k-1}x)\ e)@(\cons{\true}{d})& = & \\
(\oddFrom f\ (f (\head e))\ (\evens e))@d& = & \\
(\oddFrom f\ (f (f^{2^{k+1}-2}e))\ (\evens e))@d& = & \\
(\oddFrom f\ (f^{2^{k+1}-1}e)\ (\evens e))@d&  & 
\end{array}
\end{displaymath}

Now, for all $g$ such that $\ord{g} < \ord{d}$, $\ord{g} \leq \ord{d}-1$, so 
\begin{displaymath}
\ord{\cons{\false}{g}} = 2 + 2\ord{g} \leq 2 + 2(\ord{d} -1) = 2\ord{d} < 1+2\ord{d} = \ord{\cons{\true}{d}}
\end{displaymath}

So, $\ord{\cons{\false}{g}} < \ord{b}$, and 
\begin{displaymath}
\begin{array}{rcccl}
(\evens e)@g & = & e@(\cons{\false}{g}) & = & f^{2^k\ord{\cons{\false}{g}}+2^{k+1}-2}x \\
%& & & = & f^{2^k(2+2\ord{g})+2^{k+1}-2}x \\
%& & & = & f^{2^{k+1} + 2^{k+1}\ord{g}+2^{k+1}-2}x \\
& & & = & f^{2^{k+1}\ord{g}+2^{k+2}-2}x 
\end{array}
\end{displaymath}

Since this holds for all $g < d$ we can invoke the induction hypothesis with $k := k+1$ and $e := \evens e$.
This implies that

\begin{displaymath}
\begin{array}{rcl}
(\oddFrom f\ (f^{2^k-1}x)\ e)@b & = & (\oddFrom f\ (f^{2^{k+1}-1}x)\ (\evens e))@d \\
& = & f^{2^{k+1}d+2^{k+1}-1} x \\
%& = & f^{2^k2d+2^k+2^k-1} x \\
%& = & f^{2^k(2d+1)+2^k-1} x \\
& = & f^{2^k\ord{\cons{\true}{d}}+2^k-1} x \\
& = & f^{2^k\ord{b}+2^k-1} x
\end{array}
\end{displaymath}

If $b = \cons{\false}{d}$,

\begin{displaymath}
\begin{array}{rcl}
(\oddFrom f\ (f^{2^k-1}x)\ e)@(\cons{\false}{d})& = & (\fmap f\ (\odds e))@d \\
& = & f ((\odds e)@d)
\end{array}
\end{displaymath}

Since
$\ord{\cons{\true}{d}} = 1+2\ord{d} < 2+2\ord{d} = \ord{\cons{\false}{d}}$,

\begin{displaymath}
\begin{array}{rcccl}
f((\odds e)@d) & = & f(e@(\cons{\true}{d})) & = & f(f^{2^k\ord{\cons{\true}{d}}+2^{k+1}-2}x) \\
%& & & = & f^{1+2^k(1+2\ord{d})+2^{k+1}-2}x \\
%& & & = & f^{2^k+2^{k+1}\ord{d}+2^{k+1}-1}x \\
%& & & = & f^{2^k(2+2\ord{d})+2^k-1}x \\
& & & = & f^{2^k\ord{\cons{\false}{d}}+2^k-1}x \\
& & & = & f^{2^k\ord{b}+2^k-1}x
\end{array}
\end{displaymath}
\qed
\end{proof}

The full strength of Lemma~\ref{oddFromLemma} is only really needed in the induction hypothesis.
The statement we need for the main proof of \verb|iterate| fixes $k$ at $1$:

\begin{corollary}\label{oddFromCorollary}
For any $f, b, x, e$
if
\begin{displaymath}
\forall j . \ord{j} < \ord{b} \implies e@j = f^{\ord{\cons{\false}{j}}}x
\end{displaymath}
then
\begin{displaymath}
(\oddFrom f\ (f x)\ e)@b = f^{\ord{\cons{\true}{b}}}x
\end{displaymath}
\end{corollary}
\qed

\begin{theorem}\label{iterateCorrect}
\begin{displaymath}
\forall f\ x\ b, (\iter f\ x)@b = f^{\ord{b}} x
\end{displaymath}
\end{theorem}
\begin{proof}

We proceed by well-founded induction on $\ord{b}$.
If $b = \nil$, the equality is trivial.
Otherwise, let $b = \cons{a}{d}$.
There is a lemma that is needed whether $a$ is $\true$ or $\false$

\begin{lemma}\label{iterateSublemma}
\begin{displaymath}
(\oddFrom f\ (f x)\ \ev)@d = f^{2\ord{d}+1}x
\end{displaymath}
\end{lemma}
\begin{proof}
This is a direct result of the corollary as long as 
\begin{displaymath}
\forall j, \ord{j} < \ord{d} \implies \ev @j = f^{2\ord{j}+2}
\end{displaymath}

Since $\ord{j} < \ord{d}$, $2\ord{j}+2 < 2\ord{d}+2 \leq \ord{b}$, we can apply the induction hypothesis to $2\ord{j}+2 = \ord{\cons{\false}{j}}$:

\begin{displaymath}
\begin{array}{rcl}
(\iter f\ x)@(\cons{\false}{j}) & = & f^{\ord{\cons{\false}{j}}} x \\
\ev @j & = & f^{2\ord{j}+2}
\end{array}
\end{displaymath}
\qed
\end{proof}

Now, when $a = \true$, $(\iter f\ x)@(\cons{\true}{d}) = (\oddFrom f\ (f x)\ \ev)@d$.
By lemma~\ref{iterateSublemma}, this is just $f^{2\ord{d}+1}x = f^{\ord{b}}x$

When $a = \false$, 

\begin{displaymath}
\begin{array}{rcl}
(\iter f\ x)@(\cons{\false}{d}) & = & (\fmap f\ \od)@d \\
& = & f(\od @d) \\
& = & f((\oddFrom f\ (f x)\ \ev)@d) \\
& = & f(f^{2\ord{d}+1}x) \\
\end{array}
\end{displaymath}

With the last step justified by lemma~\ref{iterateSublemma}. This is just $f^{2\ord{d}+2}x = f^{\ord{\cons{\false}{d}}}x = f^{\ord{b}}x$.
\qed
\end{proof}

\section{Cycling possibly finite lists}

As shown in Section~\ref{logspaceCycle}, forcing a cyclic stream to depth $i$ takes $\Omega(\log i)$ space in indexable deques.
If constructed properly, a cyclic stream with cycle length $m$ can be represented as a Braun stream in $O(m^2)$ space.

To be explicit about how much memory a Braun stream is using, we will use a representation of a Braun stream that can have leaves.
The type {\tt Share} in Figure~\ref{braunRef} has a constructor {\tt Ref} that contains an integer.
This integer represents the (0-indexed) place in the stream thet the stream at the {\tt Ref} shares with.
For instance, the stream {\tt smallEyes} in Figure~\ref{braunShare} could be represented as a {\tt Share} as {\tt Branch 'i' (Ref 0) (Ref 0)}.
References are context dependent, so the locations that are {\tt Ref 0} in 
\\
{\tt Branch 'j' (Ref 0) (Branch 'i' (Ref 0) (Ref 0))}
\\
refer back to the Braun stream with 'j' at the head.
A {\tt Share} is well-formed if, for every {\tt Ref i} at location $j$, $i < j$.
This ensures that finding the value at any location in a Braun stream represented by a well-formed {\tt Share} terminates.

For $m \in \mathbb{N}$ odd, let $\beta_m$ denote the size of the subgroup of $\mathbb{Z}_m^*$ generated by $2$.
\begin{lemma}
\label{cycleSize}
A Braun stream with cycle length $2^r m$ where $m$ is odd can be represented with a {\tt Share} of size $2^{r+1} m \beta_m + 2^{r+1} - 1$.
%Furthermore, if every element in the cycle is distinct, it cannot be represented by a {\tt Share} of any smaller size.
\end{lemma}
\begin{proof}
For a list {\tt x:xs} with length $n = 2^r m$, we must produce a {\tt Share} bisimilar to {\tt bcycle x xs}:

\begin{alltt}
lcycle :: a -> [a] -> LStream a
lcycle x xs = 
  let ans = after x xs
      after y [] = Cons y ans
      after y (z:zs) = Cons y (after z zs)
  in ans

bcycle :: a -> [a] -> BS a
bcycle x xs = fromLStream (lcycle x xs)
\end{alltt}

Converting {\tt lcycle x xs} to a stream with {\tt fromLStream} produces 

{\tt fmap lhead (iterate ltail (lcycle x xs))}

Additionally, using Theorem~\ref{iterateCorrect}, it is trivial to prove that {\tt iterate} is equivalent to

\begin{alltt}
iterateSlow :: (a -> a) -> a -> Stream a
iterateSlow f x =
  let g y = f (f y)
      z = f x
  in Stream x (iterateSlow g    z) 
              (iterateSlow g (f z))
\end{alltt}

Though this definition is much more intuitive, it is also much less efficient, as {\tt f} is applied to the same values repeatedly.
It shows that every location in the Braun stream $\iter f x$ is bisimilar to $\iter f^{2^i}\ (f^j x)$ for some values of $i$ and $j$.

Applying this to {\tt bcycle x xs}, we see that every location in this Braun stream is bisimilar to 
\\
{\tt fmap lhead (iterate (ltail}$^{2^i}${\tt ) (ltail}$^j\ ${\tt (lcycle x xs)))} 
\\
for some $i$ and $j$.
We denote the stream at such a location $\langle 2^i,j \rangle$.
On any cyclic {\tt LStream} {\tt ys} with cycle length $n$, {\tt ltail}$^k\ ${\tt ys} is bisimilar to {\tt ltail}$^l\ ${\tt ys} whenever $k \equiv l \mod n$.
Therefore, any two locations $\langle i,j \rangle$ and $\langle k,l \rangle$ in the Braun stream {\tt bcycle x xs} are bisimilar if $i \equiv k \mod n$ and $j \equiv l \mod n$.

This implies that there are at most $n^2$ distinct substreams of {\tt bcycle x xs}.
With appropriate sharing, then, a {\tt bcycle x xs} can be represented by a tree with at most $n^2$ internal nodes.
Out goal will be to show that it can be represented by a tree with $2^r m \beta_m + 2^r - 1$ internal nodes.
Since a tree with $q$ internal nodes has $q+1$ leaves, this will prove the lemma.
We proceed by induction on $r$. 

If $r$ is $0$, the cycle length is odd.
Since each distinct stream location is $\langle 2^i,j \rangle$ for some $i, j$, there are at most $\beta_m m$ stream locations.

For the induction step, assume $r = s+1$ and any cycle of length $2^s m$ can be represented by a {\tt Share} with $2^s m \beta_m + 2^s - 1$ internal nodes.
By our definition of {\tt iterateSlow}, it is clear that the left subtree of {\tt bcycle x xs} is {\tt fmap lhead (iterate (ltail}$^2${\tt ) (ltail (lcycle x xs)))}.
However, since {\tt ltail (lcycle x xs)} has even cycle length, {\tt (iterate (ltail}$^2${\tt ) (ltail (lcycle x xs)))} is cyclic with cycle length $n/2$;
it is simply every second element of {\tt (x:xs)}, cycled.
By our induction hypothesis, this Braun stream can be represented by a share with $2^s m \beta_m + 2^s - 1$ internal nodes.
The same applies to the right subtree of {\tt bcycle x xs}.
Their number of internal nodes, including the internal node at the root of the {\tt Share}, is thus $1+2*(2^s m \beta_m + 2^s - 1) = 2^r m \beta_m + 2^r - 1$.
\qed
\end{proof}

In fact, this is the best we can do.

\begin{lemma}
A Braun stream {\tt bcycle x xs} with cycle length $n = 2^r m$ where $m$ is odd and there are $n$ distinct values cannot be represented with a {\tt Share} of size less than $2^{r+1} m \beta_m + 2^{r+1} - 1$.
\end{lemma}
\begin{proof}

Again we proceed by induction on $r$.
If $r$ is $0$, $n$ is odd.
We first show that every pair $\langle i'=2^i,j \rangle$ is represented in the stream.
Since $n$ is odd, $2^i \mod n$ takes on every value in $|\langle 2 \rangle|$ (the subgroup of $\mathbb{Z}_n^*$ generated by $2$) infinitely often.
In particular, $2^{i+\beta_n} \equiv 2^i \mod n$.
Additionally, for $i > \log_2 n$, at depth $i$ in the stream, all $n$ values of $\mathbb{Z}_n$ are the second part of some $\langle 2^i,j\rangle$ pair modulo $n$.

Since every pair in $\langle 2 \rangle \times \mathbb{Z}_n$ is a location in the stream, the stream must have at least $|\langle 2 \rangle \times \mathbb{Z}_n| = \beta_m m$ internal nodes.
With the additional $\beta_m m + 1$ leaves, the entire tree is at least size $2 \beta_m m + 1$.

For the induction step, assume $r = s+1$ and no cycle of length $2^s m$ can be represented by a {\tt Share} with fewer than $2^s m \beta_m + 2^s - 1$ internal nodes.
As before, the left subtree and right subtrees of {\tt bcycle x xs} are {\tt fmap lhead (iterate (ltail}$^2${\tt ) (ltail}$^{\{1,2\}}\ ${\tt (lcycle x xs)))}, respectively.
Again, since {\tt ltail (lcycle x xs)} has even cycle length, and the subtrees are cyclic with cycle length $n/2$.
The left tree is every second element of {\tt (x:xs)} (starting at the second element), cycled.
The left tree is every second element of {\tt (x:xs)} (starting at the third element, with {\tt x} appended at the end), cycled.
These lists are disjoint by assumption, so the left and right subtrees cannot have any inter-tree sharing.
Similarly, the root cannot share with either subtree, since it is cyclic with cycle length $n$ and contains values from both odd numbered and even numbered positions in {\tt (x:xs)}.

By our induction hypothesis, the left and right subtrees cannot be represented by a {\tt Share} with fewer than $2^s m \beta_m + 2^s - 1$ internal nodes.
The number of internal nodes, including the internal node at the root of the {\tt Share}, is thus $1+2*(2^s m \beta_m + 2^s - 1) = 2^r m \beta_m + 2^r - 1$.
With the leaves, this makes the tree at least size $2^{r+1} m \beta_m + 2^{r+1} - 1$
\qed
\end{proof}

When $m$ is $1$, this tree can be as small as $4n-1$.
When $\beta_n = n-1$, this tree can be as large as $2n(n-1)+1$.
A unsolved 90-year-old conjecture of Artin proposes that this occurs infinitely often \cite{artin}.


To formalize and clarify the sharing, a cyclic Braun stream will be built with explicit sharing.

To ensure that the sharing is done correctly, we use {\tt iterate}.
The functino we pass to iterate must:
\begin{itemize}
\item Be aware of the cycle length $m$
\item Collect a list of pairs $\langle i,j \rangle$ representing the locations in $\mathbb{Z}_m \times \mathbb{Z}_m$ that already have locations in the stream associated with them
\item Calculate a new pair based only on stream location
\end{itemize}

An appropriate such function is in Figure 
It produces (and consumes) a triple consisting of the real location in the stream (0-indexed), the cycle length, and a partial function mapping pairs $\langle i,j \rangle$ to stream locations.
From these triples, the function {\tt truncateFinite} 


\begin{figure}
\begin{alltt}
data Share a = Branch a (Share a) (Share a)
             | Ref Integer

type Triple = (Integer,Integer,(Integer,Integer) -> Maybe Integer)

finiteCycleAction :: Triple -> Triple
finiteCycleAction (location,m,previous) =
  (location+1,m,
   let incrHere = incrementOf location m
       offsetHere = location `mod` m
   in case previous (incrHere, offsetHere) of
        Just _ -> previous
        Nothing -> 
          let current (incr, offs) =
                case (incr==incrHere, offs==offsetHere) of
                  (Eq,Eq) -> Just location
                  _ -> previous (incr, offs)
          in current)

floorlg2 :: Integer -> Integer
floorlg2 x = 
  case x `div` 2 of
    0 -> 0
    y -> 1 + floorlg2 y

incrementOf :: Integer -> Integer -> Integer
incrementOf location m =
  (2^(floorlg2 (1+location))) `mod` m

truncateFinite :: BS Triple -> BraunRef Integer
truncateFinite (BS (loc,m,prev) od ev) =
  let incrHere = incrementOf loc m
       offsetHere = loc `mod` m
  in case prev (incrHere, offsetHere) of
       Just ref -> Ref ref
       Nothing -> BS offsetHere 
                     (truncateFinite od)
                     (truncateFinite ev)




            match f (mymod real mod,myincr real mod) with
              | None => Conr 
                        (mat whole real)
                        (truncate whole od)
                        (truncate whole ev)
              | Some bak => Ref _ bak
            end
          |inr (hed, _, _) =>
            Conr hed
            (truncate whole od)
            (truncate whole ev)
        end
    end.


floorlg2 (x:nat) \{measure id x\} :nat :=
  match div2 x with
    | 0 => 0
    | y => S (floorlg2 y)
  end.

Definition myincr real mod := 
  mymod (pow 2 (floorlg2 (S real))) mod.



CoInductive BraunRef (A:Set) : Set :=
| Conr : A -> BraunRef A -> BraunRef A -> BraunRef A
| Ref : nat -> BraunRef A.

Definition action 
  (A:Set) 
  (x:nat*nat*(nat*nat->option nat))
  : nat*nat*(nat*nat->option nat) :=
  match x with
    | inl (real,mod,f) => 
      inl _ 
      (S real,
       mod,
       match f (mymod real mod,myincr real mod) with
         | Some v => f
         | None => fun pi =>
           match pi with
             | (p,i) => 
               match (nat_compare p (mymod real mod),
                 nat_compare i (myincr real mod)) with
                 | (Eq,Eq) => Some real
                 | _ =>  f pi
               end
           end
       end)
    | inr (v,rem,sofar) =>
      match rem with
        | Nil => inl _ (S sofar,S sofar,memo (S sofar))
        | Cons hed tl => inr _ (hed,tl,S sofar)
      end
  end.

CoFixpoint truncate (A:Set) (whole:A * CoList A)
  (x:Braun ((nat*nat*(nat*nat->option nat))+(A * CoList A * nat)))
    : BraunRef A :=
    match x with
      | Conb v od ev =>
        match v with 
          | inl (real,mod,f) =>
            match f (mymod real mod,myincr real mod) with
              | None => Conr 
                        (mat whole real)
                        (truncate whole od)
                        (truncate whole ev)
              | Some bak => Ref _ bak
            end
          |inr (hed, _, _) =>
            Conr hed
            (truncate whole od)
            (truncate whole ev)
        end
    end.

\end{alltt}
\caption{}
\label{braunRef}
\end{figure}


Assume {\tt xs} is finite and of length $m$.
Then {\tt (ltail}$^j\ ${\tt (lcycle x xs))} is {\tt lcycle y ys} where 

{\tt y:ys == let k = j `mod` (m+1) in drop k (x:xs) ++ take k (x:xs)}.

Thus, {\tt (ltail}$^j\ ${\tt (lcycle x xs))} is bisimilar to {\tt (ltail}$^l\ ${\tt (lcycle x xs))} whenever $j \equiv l \mod (m+1)$.
Similarly, if {\tt ys} is a cyclic {\tt LStream} with cycle length $m+1$, {\tt (iterate (ltail}$^{2^i}${\tt ) ys}


We want fromLStream (lcycle x xs)



\begin{alltt}
CoFixpoint iterateSlow (A:Set) F (x:A) : Braun A :=
  let g := fun z => F (F z) in
    let y := F x in
      Conb x (iterateSlow g y)
             (iterateSlow g (F y)).

cycle x xs 
\end{alltt}

\begin{alltt}

Function floorlg2 (x:nat) \{measure id x\} :nat :=
  match div2 x with
    | 0 => 0
    | y => S (floorlg2 y)
  end.

Definition myincr real mod := 
  mymod (pow 2 (floorlg2 (S real))) mod.

Function mymod (n:nat) (m:nat) \{measure id n\} : nat :=
  match m with
    | 0 => 0
    | _ =>
      match nat_compare n m with
        | Lt => n
        | Eq => 0
        | Gt => mymod (n-m) m
      end
  end.

Definition action 
  (A:Set) 
  (x:(nat*nat*(nat*nat->option nat))
    +(A * CoList A * nat))
  : (nat*nat*(nat*nat->option nat))
    +(A * CoList A * nat) :=
  match x with
    | inl (real,mod,f) => 
      inl _ 
      (S real,
       mod,
       match f (mymod real mod,myincr real mod) with
         | Some v => f
         | None => fun pi =>
           match pi with
             | (p,i) => 
               match (nat_compare p (mymod real mod),
                 nat_compare i (myincr real mod)) with
                 | (Eq,Eq) => Some real
                 | _ =>  f pi
               end
           end
       end)
    | inr (v,rem,sofar) =>
      match rem with
        | Nil => inl _ (S sofar,S sofar,memo (S sofar))
        | Cons hed tl => inr _ (hed,tl,S sofar)
      end
  end.

CoInductive CoList (A:Set) : Set :=
| Nil : CoList A
| Cons : A -> CoList A -> CoList A.

CoInductive Braun (A:Set) : Set :=
| Conb : A -> Braun A -> Braun A -> Braun A.

Fixpoint mat' (A:Set) (whole:A * CoList A) (rem:CoList A) n :=
  match n with
    | 0 => 
      match rem with
        | Nil => let (ans,_) := whole in ans
        | Cons ans _ => ans
      end
    | S m =>
      match rem with
        | Nil => mat' whole (let (_,rest) := whole in rest) m
        | Cons _ rest => mat' whole rest m
      end
  end.

Definition mat (A:Set) (whole:A * CoList A) (n:nat) : A :=
  mat' whole (let (hed,tyl) := whole in Cons hed tyl) n.

CoFixpoint truncate (A:Set) (whole:A * CoList A)
  (x:Braun ((nat*nat*(nat*nat->option nat))+(A * CoList A * nat)))
    : BraunRef A :=
    match x with
      | Conb v od ev =>
        match v with 
          | inl (real,mod,f) =>
            match f (mymod real mod,myincr real mod) with
              | None => Conr 
                        (mat whole real)
                        (truncate whole od)
                        (truncate whole ev)
              | Some bak => Ref _ bak
            end
          |inr (hed, _, _) =>
            Conr hed
            (truncate whole od)
            (truncate whole ev)
        end
    end.

Definition cycle A hed tyl :=
       truncate (hed,tyl) 
         (iterate (@action A) (inr _ (hed,tyl,0))).

\end{alltt}

\section{Formalizing the proof of correctness}

how many lines?

how many generated lines?

hiccups:
* subtraction
* repeated function application not built-in (show equal to another formulation)
* proving termination separately

\section{Conclusions}

Is there a data structure that provides terminating constant-time \verb|cons|?

Also good for Braun trees, because can get index i in time $i$, not $n+i$

Formalizing in a language with extraction

Formalizing time and space complexity

\bibliographystyle{plain}
\bibliography{braun}

\end{document}

% LocalWords:  Braun deque Coq subtree subtrees bijection superlinear
% LocalWords:  oddFromEven
