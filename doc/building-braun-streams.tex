\documentclass{llncs}
%\usepackage{amsthm}
\usepackage{amssymb,amsmath,algorithmic,algorithm,verbatim,alltt}

\DeclareMathOperator{\oddFrom}{oddFromEven}
\DeclareMathOperator{\nil}{\langle\rangle}
%\DeclareMathOperator{\cons}{cons}
\DeclareMathOperator{\true}{true}
\DeclareMathOperator{\false}{false}
\DeclareMathOperator{\head}{head}
\DeclareMathOperator{\evens}{evens}
\DeclareMathOperator{\odds}{odds}
\DeclareMathOperator{\fmap}{fmap}
\DeclareMathOperator{\iter}{iterate}
\newcommand{\ord}[1]{\|#1\|}
\newcommand{\cons}[2]{#1:#2}
\DeclareMathOperator{\ev}{ev}
\DeclareMathOperator{\od}{od}
%\renewcommand{\algorithmiccomment}[1]{// #1}

\begin{comment}
\newtheorem{theorem}{Theorem}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{proposition}[theorem]{Proposition}

%\theoremstyle{definition}
\newtheorem{definition}{Definition}

\end{comment}

\begin{document}

\title{Building Braun streams efficiently}

\author{Jim Apple}

\institute{}

\maketitle

\section*{Abstract}

Braun trees are a functional data structure with logarithmic-time indexing, update, and deque operations.\cite{hoogerwoord}
They are mostly superseded by finger trees, which decrease to a constant the time required for deque operations.\cite{kaplan96purely,HinzePat}
The restrictive structural constraints that give Braun trees slower deque operations than finger trees make them well-suited for operations on infinite lists, or {\em streams}.

This paper presents two new algorithms for building Braun streams from lazy lists.
The first algorithm builds a Braun stream from a linear stream; previous algorithms to build Braun trees either require superlinear time or terminate only for finite lists.\cite{okasakiBraun} 
The second algorithm builds a cyclic Braun stream from a possibly finite list. 
When applied to finite lists of length $n$, this algorithm generates Braun streams that use $O(n^2)$ space, even when forced to arbitrary depth.
In contrast, circular streams represented with finger trees must use $\Omega(i)$ space when forced to depth $i$.

Correctness proofs of the two algorithms are presented along with formal verifications using the Coq proof assistant.

\section{Introduction}

Braun trees are a tightly-constrained functional data structure offering array and deque operations in logarithmic time.\cite{hoogerwoord,okasakiBraun} 
Modern data structures with looser constraints support constant-time deque operations, and perform better than Braun trees in practice.\cite{okasakiSkewLists}
These more permissive structures, however, make some operations unsafe when building infinite lists, or {\em streams}.

For example, a user constructing an infinite list in Haskell can write {\tt let bees = 'b' : bees} to construct a stream.
Because the cons operation on native Haskell lists does need to inspect its second argument, \verb|bees| is constructed without trouble.
An example of how this fails in Braun tree replacements is shown in Figure~\ref{consFail}.

\begin{figure}
\begin{alltt}
data Tree a = Leaf a
            | Node a (Tree a) (Tree a)
type RAL a = [(Int,Tree a)]

cons :: a -> RAL a -> RAL a
cons x xs@((size1,t1) : (size2,t2) : rest) =
    if size1 == size2
    then (1 + size1 + size2, Node x t1 t2) : rest
    else (1,Leaf x) : xs
cons x xs = (1,Leaf x) : xs
\end{alltt}
\caption{The type of skew binary random access lists and the cons operation \cite{okasakiSkewLists}.}
\label{consFail}
\end{figure}

Figure~\ref{consFail} shows the datatype definition and cons operation for Okasaki's skew binary random access lists \cite{okasakiSkewLists}.
In this representations, random access lists are linear lists containing perfectly balanced binary trees stored in order of increasing depth.
No two trees in the list are the same size unless they are the two smallest trees in the list, and no three trees in the list are ever the same size.
When the two smallest trees are the same size, the cons operation glues them together with the new head of the list.
Otherwise, it just appends the new head as a tree of size 1.


% \perp? doesn't terminate? has no WHNF?
In this implementation of random access lists, \verb|let bees = cons 'b' bees| produces $\perp$.
The cons operation must inspect the new tail before constructing the head.
On \verb|bees|, this is not a terminating operation.

\begin{figure}
\begin{alltt}
bees :: RAL Char
bees = (1,Leaf 'b') : fmap (more 'b') bees
    where 
      more :: a -> (Int,Tree a) -> (Int,Tree a)
      more v (n,t) = (1 + 2*n, Node v t t)
\end{alltt}
\caption{Constructing infinite skew binary random access lists without cons.}
\label{infiniteSkew}
\end{figure}

Of course, \verb|bees| can be constructed if we avoid cons, as shown in Figure~\ref{infiniteSkew}.
Despite this work-around, cons is still an unsafe operation.

%TODO: is it the culprit? cons also inspects the *value* of the list
The culprit is the flexibility in the shape of the random access list.
If the shape were fixed, 


see if the list is of length $2$ or more before 

Skew binary random access lists, multiple constructors, O(1) worst-case cons \cite{okasakiSkewLists}

Segmented binary, multiple constructors, O(1) worst case cons \cite{okasakiThesis}

Edison's \verb|BinaryRandList|, $O(\log n)$ worst case cons, O(1) expected case cons for non-persistent use \cite{holtersThesis}

To achieve these constant-time bounds, however, skew lists and finger trees relax their structural constraints. 
This prevents some stream constructions from terminating. 
For instance, \verb|cons| pattern matches on its second argument to determine its top-level constructor, so \verb|let ones = cons 1 ones| can never produce a top-level constructor.

In addition, the complexity of the structural constraints on skew lists and finger trees increase the memory usage of certain streams.
For instance, the stream \verb|ones| mentioned above can be stored in a Braun stream such that arbitrary indices may be retrieved without allocating more than a constant amount of memory.
Finger trees and skew lists, on the other hand, will both allocate $O(\log i)$ memory when the $i$th element is retrieved.

What does linear time mean on infinite streams?

\section{Braun streams}

Braun streams are simply infinite full binary trees.
The $0$th element is stored in the root of the tree, while odd-indexed elements appear in the left subtree and even-indexed elements appear in the right.
The subtrees of a Braun tree are also Braun trees, after reindexing by order.
That is, the 0th entry of any subtree is at its root, and its 1st, 3rd, 5th, ... elements are in its left subtree, etc.

To make this recursive relation clear, we index Braun streams by finite lists of booleans.
The root element is indexed by the empty list.
The odd-indexed elements are indexed by lists that start with \verb|True|, the even-indexed elements by lists that start with \verb|False|.
There is an obvious bijection between finite lists of booleans and integers;
it is expressed in \verb|ord| and \verb|list| in Figure~\ref{basicCode}.

\begin{figure}
\begin{alltt}
data Stream a = Stream a (Stream a) (Stream a) 

bat :: Stream a -> [Bool] -> a
bat (Stream h _ _) [] = h
bat (Stream _ o _) (True:r) = bat o r
bat (Stream _ _ e) (False:r) = bat e r

ord :: [Bool] -> Integer
ord [] = 0
ord (True:r) = 1 + 2*(ord r)
ord (False:r) = 2 + 2*(ord r)

list :: Integer -> [Bool]
list 0 = []
list n = 
    case x `mod` 2 of
      | 1 -> False:(list ((x-1)`div`2))
      | 0 -> True:(list ((x-2)`div`2))

head :: Stream a -> a
head (Stream h _ _) = h

odds :: Stream a -> Stream a
odds (Stream _ o _) = o

evens :: Stream a -> Stream a
evens (Stream _ _ e) = e
\end{alltt}
\caption{The basic definitions of Braun streams with their ordering as written in Haskell.}
\label{basicCode}
\end{figure}

\section{Building Braun streams from cons streams}

The algorithm for building a Braun stream from a linear stream (along with supporting code) is displayed in Figure~\ref{iterateCode}.

\begin{figure}
\begin{alltt}
instance Functor Stream where
    fmap f (Stream p q r) = Stream (f p) (fmap f q) (fmap f r)

oddFromEven :: (a -> b) -> b -> Stream a -> Stream b
oddFromEven f x  \(\sim\)(Stream h od ev) =
    Stream x (oddFromEven f (f h) ev) (fmap f od)

iterate :: (a -> a) -> a -> Stream a
iterate f x =
    let ev = fmap f od
        od = oddFromEven f (f x) ev
    in
      Stream x od ev

data LStream a = Cons a (LStream a)

ltail :: LStream a -> LStream a
ltail (Cons _ xs) = xs

lhead :: LStream a -> a
lhead (Cons x _) = x

fromLStream :: LStream a -> Stream a
fromLStream s = fmap lhead (iterate ltail s)
\end{alltt}
\caption{The algorithm for building a Braun stream from a linear stream in Haskell}
\label{iterateCode}
\end{figure}

For the proofs, \verb|ord l| is written $\ord{l}$ and \verb|bat s l| is written $s@l$.

\begin{lemma}\label{oddFromLemma}
For any $f, b, x, e, k$
if
\begin{displaymath}
\forall j . \ord{j} < \ord{b} \implies e@j = f^{2^k\ord{j}+2^{k+1}-2}x
\end{displaymath}
then
\begin{displaymath}
(\oddFrom f\ (f^{2^k-1}x)\ e)@b = f^{2^k\ord{b}+2^k-1}x
\end{displaymath}
\end{lemma}
\begin{proof}
We prove this by structural induction on $b$. If $b = \nil$, then 
\begin{displaymath}
\begin{array}{rcl}
(\oddFrom f\ (f^{2^k-1}x)\ e)@b & = & (\oddFrom f\ (f^{2^k-1}x)\ e)@\nil \\
& = & f^{2^k-1}x \\
& = & f^{0+2^k-1}x \\
& = & f^{2^k\ord{\nil}+2^k-1}x \\
& = & f^{2^k\ord{b}+2^k-1}x
\end{array}
\end{displaymath}

If $b = \cons{\true}{d}$,
\begin{displaymath}
\begin{array}{rcl}
(\oddFrom f\ (f^{2^k-1}x)\ e)@(\cons{\true}{d})& = & \\
(\oddFrom f\ (f (\head e))\ (\evens e))@d& = & \\
(\oddFrom f\ (f (f^{2^{k+1}-2}e))\ (\evens e))@d& = & \\
(\oddFrom f\ (f^{2^{k+1}-1}e)\ (\evens e))@d&  & 
\end{array}
\end{displaymath}

Now, for all $g$ such that $\ord{g} < \ord{d}$, $\ord{g} \leq \ord{d}-1$, so 
\begin{displaymath}
\ord{\cons{\false}{g}} = 2 + 2\ord{g} \leq 2 + 2(\ord{d} -1) = 2\ord{d} < 1+2\ord{d} = \ord{\cons{\true}{d}}
\end{displaymath}

So, $\ord{\cons{\false}{g}} < \ord{b}$, and 
\begin{displaymath}
\begin{array}{rcccl}
(\evens e)@g & = & e@(\cons{\false}{g}) & = & f^{2^k\ord{\cons{\false}{g}}+2^{k+1}-2}x \\
%& & & = & f^{2^k(2+2\ord{g})+2^{k+1}-2}x \\
%& & & = & f^{2^{k+1} + 2^{k+1}\ord{g}+2^{k+1}-2}x \\
& & & = & f^{2^{k+1}\ord{g}+2^{k+2}-2}x 
\end{array}
\end{displaymath}

Since this holds for all $g < d$ we can invoke the induction hypothesis with $k := k+1$ and $e := \evens e$.
This implies that

\begin{displaymath}
\begin{array}{rcl}
(\oddFrom f\ (f^{2^k-1}x)\ e)@b & = & (\oddFrom f\ (f^{2^{k+1}-1}x)\ (\evens e))@d \\
& = & f^{2^{k+1}d+2^{k+1}-1} x \\
%& = & f^{2^k2d+2^k+2^k-1} x \\
%& = & f^{2^k(2d+1)+2^k-1} x \\
& = & f^{2^k\ord{\cons{\true}{d}}+2^k-1} x \\
& = & f^{2^k\ord{b}+2^k-1} x
\end{array}
\end{displaymath}

If $b = \cons{\false}{d}$,

\begin{displaymath}
\begin{array}{rcl}
(\oddFrom f\ (f^{2^k-1}x)\ e)@(\cons{\false}{d})& = & (\fmap f\ (\odds e))@d \\
& = & f ((\odds e)@d)
\end{array}
\end{displaymath}

Since
$\ord{\cons{\true}{d}} = 1+2\ord{d} < 2+2\ord{d} = \ord{\cons{\false}{d}}$,

\begin{displaymath}
\begin{array}{rcccl}
f((\odds e)@d) & = & f(e@(\cons{\true}{d})) & = & f(f^{2^k\ord{\cons{\true}{d}}+2^{k+1}-2}x) \\
%& & & = & f^{1+2^k(1+2\ord{d})+2^{k+1}-2}x \\
%& & & = & f^{2^k+2^{k+1}\ord{d}+2^{k+1}-1}x \\
%& & & = & f^{2^k(2+2\ord{d})+2^k-1}x \\
& & & = & f^{2^k\ord{\cons{\false}{d}}+2^k-1}x \\
& & & = & f^{2^k\ord{b}+2^k-1}x
\end{array}
\end{displaymath}

\end{proof}

The full strength of Lemma~\ref{oddFromLemma} is only really needed in the induction hypothesis.
The statement we need for the main proof of \verb|iterate| fixes $k$ at $1$:

\begin{corollary}\label{oddFromCorollary}
For any $f, b, x, e$
if
\begin{displaymath}
\forall j . \ord{j} < \ord{b} \implies e@j = f^{\ord{\cons{\false}{j}}}x
\end{displaymath}
then
\begin{displaymath}
(\oddFrom f\ (f x)\ e)@b = f^{\ord{\cons{\true}{b}}}x
\end{displaymath}
\end{corollary}
\qed

\begin{theorem}\label{iterateCorrect}
\begin{displaymath}
\forall f\ x\ b, (\iter f\ x)@b = f^{\ord{b}} x
\end{displaymath}
\end{theorem}
\begin{proof}

We proceed by well-founded induction on $\ord{b}$.
If $b = \nil$, the equality is trivial.
Otherwise, let $b = \cons{a}{d}$.
There is a lemma that is needed whether $a$ is $\true$ or $\false$

\begin{lemma}\label{iterateSublemma}
\begin{displaymath}
(\oddFrom f\ (f x)\ \ev)@d = f^{2\ord{d}+1}x
\end{displaymath}
\end{lemma}
\begin{proof}
This is a direct result of the corollary as long as 
\begin{displaymath}
\forall j, \ord{j} < \ord{d} \implies \ev @j = f^{2\ord{j}+2}
\end{displaymath}

Since $\ord{j} < \ord{d}$, $2\ord{j}+2 < 2\ord{d}+2 \leq \ord{b}$, we can apply the induction hypothesis to $2\ord{j}+2 = \ord{\cons{\false}{j}}$:

\begin{displaymath}
\begin{array}{rcl}
(\iter f\ x)@(\cons{\false}{j}) & = & f^{\ord{\cons{\false}{j}}} x \\
\ev @j & = & f^{2\ord{j}+2}
\end{array}
\end{displaymath}

\end{proof}

Now, when $a = \true$, $(\iter f\ x)@(\cons{\true}{d}) = (\oddFrom f\ (f x)\ \ev)@d$.
By lemma~\ref{iterateSublemma}, this is just $f^{2\ord{d}+1}x = f^{\ord{b}}x$

When $a = \false$, 

\begin{displaymath}
\begin{array}{rcl}
(\iter f\ x)@(\cons{\false}{d}) & = & (\fmap f\ \od)@d \\
& = & f(\od @d) \\
& = & f((\oddFrom f\ (f x)\ \ev)@d) \\
& = & f(f^{2\ord{d}+1}x) \\
\end{array}
\end{displaymath}

With the last step justified by lemma~\ref{iterateSublemma}. This is just $f^{2\ord{d}+2}x = f^{\ord{\cons{\false}{d}}}x = f^{\ord{b}}x$.

\end{proof}

\section{Cycling possibly finite lists}

\begin{alltt}

Function floorlg2 (x:nat) \{measure id x\} :nat :=
  match div2 x with
    | 0 => 0
    | y => S (floorlg2 y)
  end.

Definition myincr real mod := 
  mymod (pow 2 (floorlg2 (S real))) mod.

Function mymod (n:nat) (m:nat) \{measure id n\} : nat :=
  match m with
    | 0 => 0
    | _ =>
      match nat_compare n m with
        | Lt => n
        | Eq => 0
        | Gt => mymod (n-m) m
      end
  end.

Definition action 
  (A:Set) 
  (x:(nat*nat*(nat*nat->option nat))
    +(A * CoList A * nat))
  : (nat*nat*(nat*nat->option nat))
    +(A * CoList A * nat) :=
  match x with
    | inl (real,mod,f) => 
      inl _ 
      (S real,
       mod,
       match f (mymod real mod,myincr real mod) with
         | Some v => f
         | None => fun pi =>
           match pi with
             | (p,i) => 
               match (nat_compare p (mymod real mod),
                 nat_compare i (myincr real mod)) with
                 | (Eq,Eq) => Some real
                 | _ =>  f pi
               end
           end
       end)
    | inr (v,rem,sofar) =>
      match rem with
        | Nil => inl _ (S sofar,S sofar,memo (S sofar))
        | Cons hed tl => inr _ (hed,tl,S sofar)
      end
  end.

CoInductive CoList (A:Set) : Set :=
| Nil : CoList A
| Cons : A -> CoList A -> CoList A.

CoInductive Braun (A:Set) : Set :=
| Conb : A -> Braun A -> Braun A -> Braun A.

CoInductive BraunRef (A:Set) : Set :=
| Conr : A -> BraunRef A -> BraunRef A -> BraunRef A
| Ref : nat -> BraunRef A.

Fixpoint mat' (A:Set) (whole:A * CoList A) (rem:CoList A) n :=
  match n with
    | 0 => 
      match rem with
        | Nil => let (ans,_) := whole in ans
        | Cons ans _ => ans
      end
    | S m =>
      match rem with
        | Nil => mat' whole (let (_,rest) := whole in rest) m
        | Cons _ rest => mat' whole rest m
      end
  end.

Definition mat (A:Set) (whole:A * CoList A) (n:nat) : A :=
  mat' whole (let (hed,tyl) := whole in Cons hed tyl) n.

CoFixpoint truncate (A:Set) (whole:A * CoList A)
  (x:Braun ((nat*nat*(nat*nat->option nat))+(A * CoList A * nat)))
    : BraunRef A :=
    match x with
      | Conb v od ev =>
        match v with 
          | inl (real,mod,f) =>
            match f (mymod real mod,myincr real mod) with
              | None => Conr 
                        (mat whole real)
                        (truncate whole od)
                        (truncate whole ev)
              | Some bak => Ref _ bak
            end
          |inr (hed, _, _) =>
            Conr hed
            (truncate whole od)
            (truncate whole ev)
        end
    end.

Definition cycle A hed tyl :=
       truncate (hed,tyl) 
         (iterate (@action A) (inr _ (hed,tyl,0))).

\end{alltt}

\section{Formalizing the proof of correctness}

how many lines?

how many generated lines?

hiccups:
* subtraction
* repeated function application not built-in (show equal to another formulation)
* proving termination separately

\section{Conclusions}

Is there a data structure that provides terminating constant-time \verb|cons|?

Also good for Braun trees, because can get index i in time $i$, not $n+i$

Formalizing in a language with extraction

Formalizing time and space complexity

\bibliographystyle{plain}
\bibliography{braun}

\end{document}

% LocalWords:  Braun deque Coq subtree subtrees bijection superlinear
% LocalWords:  oddFromEven
