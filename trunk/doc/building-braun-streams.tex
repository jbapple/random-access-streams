\documentclass[envcountsect]{llncs}
%\usepackage{amsthm}
\usepackage{amssymb,amsmath,algorithmic,algorithm,verbatim,alltt,url}

\DeclareMathOperator{\oddFrom}{oddFromEven}
\DeclareMathOperator{\nil}{\langle\rangle}
%\DeclareMathOperator{\cons}{cons}
\DeclareMathOperator{\true}{true}
\DeclareMathOperator{\false}{false}
\DeclareMathOperator{\head}{head}
\DeclareMathOperator{\evens}{evens}
\DeclareMathOperator{\odds}{odds}
\DeclareMathOperator{\fmap}{fmap}
\DeclareMathOperator{\iter}{iterate}
\newcommand{\ord}[1]{\|#1\|}
\newcommand{\cons}[2]{#1:#2}
\DeclareMathOperator{\ev}{ev}
\DeclareMathOperator{\od}{od}
\newcommand{\app}{+\!\!\!+\ }
\newcommand{\share}{{\tt Share} }
%\renewcommand{\algorithmiccomment}[1]{// #1}

\begin{comment}
\newtheorem{theorem}{Theorem}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{observation}[theorem]{Observation}
\newtheorem{proposition}[theorem]{Proposition}

%\theoremstyle{definition}
\newtheorem{definition}{Definition}

\end{comment}

\begin{document}

\title{Building Braun Streams Efficiently}

\author{Jim Apple}

\institute{}

\maketitle

\section*{Abstract}

Braun trees are a functional data structure with logarithmic-time indexing, update, and deque operations.\cite{hoogerwoord}
They are mostly superseded by finger trees, which decrease to a constant the time required for deque operations.\cite{kaplan96purely,HinzePat}
The restrictive structural constraints that give Braun trees slower deque operations than finger trees make them well-suited for operations on infinite lists, or {\em streams}.

This paper presents two new algorithms for building Braun streams from lazy lists.
The first algorithm builds a Braun stream from a linear stream; previous algorithms to build Braun trees either require superlinear time or terminate only for finite lists.\cite{okasakiBraun} 
The second algorithm builds a cyclic Braun stream from a possibly finite list. 
When applied to finite lists of length $n$, this algorithm generates Braun streams that use $O(n^2)$ space, even when forced to arbitrary depth.
In contrast, circular streams represented with finger trees must use $\Omega(i)$ space when forced to depth $i$.

Correctness proofs of the two algorithms are presented along with formal verifications using the Coq proof assistant.

\section{Introduction}
\label{logspaceCycle}

Braun trees are a tightly-constrained functional data structure offering array and deque operations in logarithmic time.\cite{hoogerwoord,okasakiBraun} 
Modern data structures with looser constraints support constant-time deque operations, and perform better than Braun trees in practice.\cite{HinzePat,okasakiSkewLists}
These more permissive structures, however, make some operations unsafe when building infinite lists, or {\em streams}.

For example, a user constructing an infinite list in Haskell can write {\tt let bees = 'b' : bees} to construct a stream.
Because the cons operation on native Haskell lists does need to inspect its second argument, {\tt bees} is constructed without trouble.
An example of how this fails in a typical modern random-access list is shown in Fig.~\ref{23consFail}.

\begin{figure}
\begin{alltt}
data Node a = N2 a a
            | N3 a a a
data Digit a = D1 a
             | D2 a a
             | D3 a a a
             | D4 a a a a
data TTT a = TTT (Digit a) (TTT (Node a))

cons :: a -> TTT a -> TTT a
cons p (TTT (D1 q)       ds) = TTT (D2 p q) ds
cons p (TTT (D2 q r)     ds) = TTT (D3 p q r) ds
cons p (TTT (D3 q r s)   ds) = TTT (D4 p q r s) ds
cons p (TTT (D4 q r s t) ds) = TTT (D2 p q) (cons (N3 r s t) ds)

dangerousBees :: TTT Char
dangerousBees = cons 'b' dangerousBees

stream :: a -> TTT a
stream x = TTT (D2 x x) (stream (N2 x x))

safeBees :: TTT Char
safeBees = stream 'b'
\end{alltt}
\caption{
A simplification of 2-3 finger trees for use as a stream \cite{HinzePat}. 
Use of {\tt cons} as in {\tt dangerousBees} produces $\bot$, but a stream like {\tt safeBees} can be created while avoiding {\tt cons}.
However, {\tt safeBees} uses $\Omega(\log i)$ space when forced to depth $i$.
}
\label{23consFail}
\label{23stream}
\end{figure}

Figure~\ref{23consFail} shows the datatype definition and {\tt cons} operation for Hinze and Paterson's 2-3 finger trees \cite{HinzePat}.
In this representation, streams are linear lists of trees of increasing depth generated by nesting {\tt Node}s.
At the top of each tree is a {\tt Digit} containing one to four {\tt Node} trees.

The {\tt cons} operation, in order to produce the first {\tt Digit} in the stream, needs to know the first {\tt Digit} in the rest of the stream.
For streams like {\tt dangerousBees}, {\tt cons} must know the first {\tt Digit} in the stream in order to produce the first {\tt Digit} in the stream.
Because of this, {\tt dangerousBees} is actually undefined.

Though {\tt cons} is an unsafe operation, streams can still be built of 2-3 finger trees by avoiding {\tt cons}.
Figure~\ref{23stream} also shows {\tt safeBees}, which does not evaluate to $\bot$, unlike {\tt dangerousBees}.
On the other hand, it uses $\Omega(\log i)$ space when forced to depth $i$.

\begin{figure}
\begin{alltt}
data BS a = BS \{head::a, 
                odds::BS a, 
                evens::BS a\}

cons x \(\sim\)(BS h o e) = BS x (cons h e) o

eyes :: BS Char
eyes = cons 'i' eyes

smallEyes :: BS Char
smallEyes = 
  let ans = BS 'i' ans ans 
  in ans
\end{alltt}
\caption{
Braun streams along with their {\tt cons} operation.
The ``$\sim$'' before the pattern match in {\tt cons} is an {\em irrefutable pattern} -- a pattern which is matched lazily \cite{haskellReport}.
The {\tt cons} operation is safe, so the stream {\tt eyes} is not $\bot$.
The stream {\tt smallEyes} only takes up $O(1)$ space.
}
\label{braunDef}
\label{braunCons}
\label{braunShare}
\end{figure}

Figure~\ref{braunCons} illustrates that Braun streams are better suited for these cases.
First, {\tt cons} is safe.
The result of an application of {\tt cons} is guarenteed to have {\tt BS} as its top-level constructor.
The irrefutable pattern matching in the definition of {\tt cons}, denoted by ``$\sim$'', ensures that the top-level constructor is pattern matched lazily.
The definition of {\tt cons} given is thus equivalent to:

\begin{alltt}
cons x y =
  BS x
     (cons (head y) (evens y))
     (odds y)
\end{alltt}

Since {\tt cons} for Braun streams does not need to match the top-level constructor of its tail until its own top-level constructor is chosen, {\tt eyes} in Fig.~\ref{braunCons} is well-formed.
Additionally, unlike {\tt safeBees} in Fig.~\ref{23stream}, {\tt smallEyes} in Fig.~\ref{braunShare} can reuse its representation in its subtrees to use only $O(1)$ space, even when forced to arbitrary depth.

Like 2-3 finger trees, other stream candidates offering $O(1)$ deque operations do not support safe {\tt cons} or constant-space construction of repeating streams. This includes:

\begin{itemize}
\item Skew binary random access lists, which offer $O(1)$ worst-case {\tt cons} \cite{okasakiSkewLists}
\item Edison's \verb|BinaryRandList|, which supports {\tt cons} in $O(\log n)$ worst case time and $O(1)$ expected time \cite{edison,holtersThesis}
\item Segmented binary lists, which offer $O(1)$ worst case {\tt cons} \cite{okasakiThesis}
\end{itemize}

%What does linear time mean on infinite streams?

\section{Braun Streams}
\label{braunDef}

Braun streams are simply infinite full binary trees.
The $0$th element is stored in the root of the tree, while odd-indexed elements appear in the left subtree and even-indexed elements appear in the right.
The subtrees of a Braun tree are also Braun trees, after reindexing by order.
That is, the 0th entry of any subtree is at its root, and its 1st, 3rd, 5th, ... elements are in its left subtree, etc.

To make this recursive relation clear, we index Braun streams by finite lists of booleans.
The root element is indexed by the empty list.
The odd-indexed elements are indexed by lists that start with \verb|True|, the even-indexed elements by lists that start with \verb|False|.
There is an obvious bijection between finite lists of booleans and integers;
it is expressed in \verb|ord| and \verb|list| in Fig.~\ref{basicCode}.

\begin{figure}
\begin{alltt}
bat :: BS a -> [Bool] -> a
bat (BS h _ _) [] = h
bat (BS _ o _) (True:r) = bat o r
bat (BS _ _ e) (False:r) = bat e r

ord :: [Bool] -> Integer
ord [] = 0
ord (True:r) = 1 + 2*(ord r)
ord (False:r) = 2 + 2*(ord r)

list :: Integer -> [Bool]
list 0 = []
list n = 
    case x `mod` 2 of
      | 1 -> False:(list ((x-1)`div`2))
      | 0 -> True:(list ((x-2)`div`2))
\end{alltt}
\caption{Indexing into Braun streams and index conversions in Haskell.
See Figure~\ref{braunDef} for the definition of the {\tt BS} datatype.}
\label{basicCode}
\end{figure}

\section{Building Braun Streams from Linear Streams}
\label{iterSect}

The algorithm for building a Braun stream from a linear stream (along with supporting code) is displayed in Fig.~\ref{iterateCode}.

\begin{figure}
\begin{alltt}
instance Functor BS where
    fmap f (BS h o e) = BS (f h) (fmap f o) (fmap f e)

oddFromEven :: (a -> a) -> a -> BS a -> BS a
oddFromEven f x  \(\sim\)(BS h od ev) =
    BS x (oddFromEven f (f h) ev) (fmap f od)

iterate :: (a -> a) -> a -> BS a
iterate f x =
    let ev = fmap f od
        od = oddFromEven f (f x) ev
    in
      BS x od ev

data LStream a = Cons \{lhead::a,
                       ltail::LStream a\}

fromLStream :: LStream a -> Stream a
fromLStream s = fmap lhead (iterate ltail s)
\end{alltt}
\caption{The algorithm for building a Braun stream from a linear stream in Haskell}
\label{iterateCode}
\end{figure}

For the proofs, \verb|ord l| is written $\ord{l}$ and \verb|bat s l| is written $s@l$.

\begin{lemma}\label{oddFromLemma}
For any $f, b, x, e, k$
if
\begin{displaymath}
\forall j . \ord{j} < \ord{b} \implies e@j = f^{2^k\ord{j}+2^{k+1}-2}x
\end{displaymath}
then
\begin{displaymath}
(\oddFrom f\ (f^{2^k-1}x)\ e)@b = f^{2^k\ord{b}+2^k-1}x\enspace.
\end{displaymath}
\end{lemma}
\begin{proof}
We prove this by structural induction on $b$. If $b = \nil$, then 
\begin{displaymath}
\begin{array}{rcl}
(\oddFrom f\ (f^{2^k-1}x)\ e)@b & = & (\oddFrom f\ (f^{2^k-1}x)\ e)@\nil \\
& = & f^{2^k-1}x \\
& = & f^{0+2^k-1}x \\
& = & f^{2^k\ord{\nil}+2^k-1}x \\
& = & f^{2^k\ord{b}+2^k-1}x
\end{array}
\end{displaymath}

If $b = \cons{\true}{d}$,
\begin{displaymath}
\begin{array}{rcl}
(\oddFrom f\ (f^{2^k-1}x)\ e)@(\cons{\true}{d})& = & \\
(\oddFrom f\ (f (\head e))\ (\evens e))@d& = & \\
(\oddFrom f\ (f (f^{2^{k+1}-2}e))\ (\evens e))@d& = & \\
(\oddFrom f\ (f^{2^{k+1}-1}e)\ (\evens e))@d&  & 
\end{array}
\end{displaymath}

Now, for all $g$ such that $\ord{g} < \ord{d}$, $\ord{g} \leq \ord{d}-1$, so 
\begin{displaymath}
\ord{\cons{\false}{g}} = 2 + 2\ord{g} \leq 2 + 2(\ord{d} -1) = 2\ord{d} < 1+2\ord{d} = \ord{\cons{\true}{d}}
\end{displaymath}

So, $\ord{\cons{\false}{g}} < \ord{b}$, and 
\begin{displaymath}
\begin{array}{rcccl}
(\evens e)@g & = & e@(\cons{\false}{g}) & = & f^{2^k\ord{\cons{\false}{g}}+2^{k+1}-2}x \\
%& & & = & f^{2^k(2+2\ord{g})+2^{k+1}-2}x \\
%& & & = & f^{2^{k+1} + 2^{k+1}\ord{g}+2^{k+1}-2}x \\
& & & = & f^{2^{k+1}\ord{g}+2^{k+2}-2}x 
\end{array}
\end{displaymath}

Since this holds for all $g < d$ we can invoke the induction hypothesis with $k := k+1$ and $e := \evens e$.
This implies that

\begin{displaymath}
\begin{array}{rcl}
(\oddFrom f\ (f^{2^k-1}x)\ e)@b & = & (\oddFrom f\ (f^{2^{k+1}-1}x)\ (\evens e))@d \\
& = & f^{2^{k+1}d+2^{k+1}-1} x \\
%& = & f^{2^k2d+2^k+2^k-1} x \\
%& = & f^{2^k(2d+1)+2^k-1} x \\
& = & f^{2^k\ord{\cons{\true}{d}}+2^k-1} x \\
& = & f^{2^k\ord{b}+2^k-1} x
\end{array}
\end{displaymath}

If $b = \cons{\false}{d}$,

\begin{displaymath}
\begin{array}{rcl}
(\oddFrom f\ (f^{2^k-1}x)\ e)@(\cons{\false}{d})& = & (\fmap f\ (\odds e))@d \\
& = & f ((\odds e)@d)
\end{array}
\end{displaymath}

Since
$\ord{\cons{\true}{d}} = 1+2\ord{d} < 2+2\ord{d} = \ord{\cons{\false}{d}}$,

\begin{displaymath}
\begin{array}{rcccl}
f((\odds e)@d) & = & f(e@(\cons{\true}{d})) & = & f(f^{2^k\ord{\cons{\true}{d}}+2^{k+1}-2}x) \\
%& & & = & f^{1+2^k(1+2\ord{d})+2^{k+1}-2}x \\
%& & & = & f^{2^k+2^{k+1}\ord{d}+2^{k+1}-1}x \\
%& & & = & f^{2^k(2+2\ord{d})+2^k-1}x \\
& & & = & f^{2^k\ord{\cons{\false}{d}}+2^k-1}x \\
& & & = & f^{2^k\ord{b}+2^k-1}x
\end{array}
\end{displaymath}
\qed
\end{proof}

The full strength of Lemma~\ref{oddFromLemma} is only really needed in the induction hypothesis.
The statement we need for the main proof of \verb|iterate| fixes $k$ at $1$:

\begin{corollary}\label{oddFromCorollary}
For any $f, b, x, e$
if
\begin{displaymath}
\forall j . \ord{j} < \ord{b} \implies e@j = f^{\ord{\cons{\false}{j}}}x
\end{displaymath}
then
\begin{displaymath}
(\oddFrom f\ (f x)\ e)@b = f^{\ord{\cons{\true}{b}}}x
\end{displaymath}
\end{corollary}
\qed

\begin{theorem}\label{iterateCorrect}
\begin{displaymath}
\forall f\ x\ b, (\iter f\ x)@b = f^{\ord{b}} x
\end{displaymath}
\end{theorem}
\begin{proof}

We proceed by well-founded induction on $\ord{b}$.
If $b = \nil$, the equality is trivial.
Otherwise, let $b = \cons{a}{d}$.
There is a lemma that is needed whether $a$ is $\true$ or $\false$

\begin{lemma}\label{iterateSublemma}
\begin{displaymath}
(\oddFrom f\ (f x)\ \ev)@d = f^{2\ord{d}+1}x
\end{displaymath}
\end{lemma}
\begin{proof}
This is a direct result of the corollary as long as 
\begin{displaymath}
\forall j, \ord{j} < \ord{d} \implies \ev @j = f^{2\ord{j}+2}
\end{displaymath}

Since $\ord{j} < \ord{d}$, $2\ord{j}+2 < 2\ord{d}+2 \leq \ord{b}$, we can apply the induction hypothesis to $2\ord{j}+2 = \ord{\cons{\false}{j}}$:

\begin{displaymath}
\begin{array}{rcl}
(\iter f\ x)@(\cons{\false}{j}) & = & f^{\ord{\cons{\false}{j}}} x \\
\ev @j & = & f^{2\ord{j}+2}
\end{array}
\end{displaymath}
\qed
\end{proof}

Now, when $a = \true$, $(\iter f\ x)@(\cons{\true}{d}) = (\oddFrom f\ (f x)\ \ev)@d$.
By lemma~\ref{iterateSublemma}, this is just $f^{2\ord{d}+1}x = f^{\ord{b}}x$

When $a = \false$, 

\begin{displaymath}
\begin{array}{rcl}
(\iter f\ x)@(\cons{\false}{d}) & = & (\fmap f\ \od)@d \\
& = & f(\od @d) \\
& = & f((\oddFrom f\ (f x)\ \ev)@d) \\
& = & f(f^{2\ord{d}+1}x) \\
\end{array}
\end{displaymath}

With the last step justified by lemma~\ref{iterateSublemma}. This is just $f^{2\ord{d}+2}x = f^{\ord{\cons{\false}{d}}}x = f^{\ord{b}}x$.
\qed
\end{proof}

\section{Cycling Possibly Finite Lists}

As shown in Sect.~\ref{logspaceCycle}, forcing a cyclic stream to depth $i$ takes $\Omega(\log i)$ space in indexable deques.
If constructed properly, a cyclic stream with cycle length $m$ can be represented as a Braun stream in $O(m^2)$ space.
This section describes an algorithm to produce a cyclic Braun stream of minimal size.

In our implementation of Braun streams in a Haskell library, sharing is indicated to the compiler by reusing the same variable more than once in an expression \cite{website}.
For the purposes of the proofs in this section, it will help to be explicit about how much memory a Braun stream occupies by using a representation that can have leaves.
This representation is presented as the datatype {\tt Share} in Fig.~\ref{shareDef}.
The leaves contain lists of booleans; we call these {\em pointers}, and they correspond to locations as in Sect.~\ref{braunDef}.
In {\tt Share}s, unlike in Braun streams, some locations are {\em invalid} because they are cut off by a leaf.

A pointer or location $b$ can be {\em traced} in a \share $s$, producing a value from $s$, as in {\tt trace} in Fig.~\ref{traceDef}.
If $b$ is a valid location in $s$, it may point to either a {\tt Branch} or a {\tt Ref}.
If it points to a {\tt Branch}, the value at that {\tt Branch} is the result of the trace.
If it points to a {\tt Ref} with pointer $p$ and $p$ traces to a value $v$, $v$ is the result of the trace at $b$.
An invalid path $b$ is interrupted at some point by a {\tt Ref}.
Call the pointer at that {\tt Ref} $p$, and the remaining portion of $b$ $r$.
If $p \app r$ traces to a value $v$, $v$ is the result of the trace of $b$.

\begin{figure}
\begin{alltt}
data Share a = Branch a (Share a) (Share a)
             | Ref [Bool]


context g (Branch v _ _) [] = v
context g (Branch _ o _) (True:r) = context g o r
context g (Branch _ _ e) (False:r) = context g e r
context g (Ref p) r = context g g (p++r)

trace g b = context g g b
\end{alltt}
\caption{A definition of Braun streams with explicit sharing in Haskell, along with a function {\tt trace} that potentially extracts a value from the {\tt Share} for a location given as a {\tt [Bool]}.}
\label{shareDef}
\label{traceDef}
\end{figure}

Tracing a location in a \share may not always produce a value.
For example, in {\tt Ref []}, no locations trace to values.
If every list of booleans traces to a value in a \share $s$, we say $s$ is {\em well-formed}.
In that case, we denote the trace of $l$ in $s$ by $s@l$, similar to indexing in Braun streams.
This is the same notation as indexing in Braun streams, which facilitates the following definition:

\begin{definition}
A Braun stream or well-formed \share $a$ is {\em equivalent} to a Braun stream or well-formed \share $b$ when $a@l = b@l$ for all $l$,.
\end{definition}

\begin{comment}
The type \share has a constructor {\tt Ref} that contains an list of booleans.
We call this list a {\em pointer}; a pointer represents a location.
a pointer $p$ at location $l$ indicates that the it points to a location in the stream that is bisimilar to the location in the stream that the stream at the {\tt Ref} shares with.
For instance, the stream {\tt smallEyes} in Fig.~\ref{braunShare} could be represented as a \share as {\tt Branch 'i' (Ref []) (Ref [])}.
References are context dependent, so the locations that are {\tt Ref []} in 
{\tt Branch 'j' (Ref []) (Branch 'i' (Ref []) (Ref []))}
refer back to the Braun stream with 'j' at the head.
If in a \share $s$ every list of booleans traces to a value, we say $s$ is {\em valid}.
A \share is called {\em well-formed} if, for every {\tt Ref b} at location $l$, $\ord{b} < \ord{l}$.
A valid \share can be transformed into a well-formed \share of equivalent size.
First, ensure every {\tt Ref} points to a {\tt Branch}.
This is possible since a {\tt Ref} at location $b$ traces (by the validity of $s$) to a {\tt Branch}.
This does not increase the size of the tree at all, as it simple replaces the pointers at certain {\tt Ref}s
Now if any {\tt Ref}s point to {\tt Branch}es with higher-numbered locations, 
Let $s$ be a valid {\tt Share}, and let $b$ point to a {\tt Ref} in $s$ that 
This ensures that finding the value at any location in a Braun stream represented by a well-formed \share terminates.
Attempting to find a value in a well-formed \share at location $b$ obviously succeeds if $b$ is a valid path in the tree.
If it is not, it must be interrupted by a leaf.
Assume the leaf is at location $l$ and refers to location $p$.
Then there is some finite list of booleans $r$ such that $l \app r = b$.
This is the remainder of $b$ that was not followed because the search was interrupted by the leaf at $l$.
Following the reference at $l$ would point us to the location $\ord{p \app r}$.
Since $\ord{p} < \ord{l}$, $\ord{p \app r} < \ord{l \app r} = \ord{b}$.
Thus, following a reference in a well-formed \share points to a smaller location, ensuring that following references terminates.
We will call the process of following a reference ``{\em resolving} a reference''.
In fact, any valid share is equivalent to a well-formed shares 
\end{comment}

\subsection{Minimum Size of Cyclic Braun Streams}

For odd $m \in \mathbb{N}$, let $\beta_m$ denote the size of the subgroup of $\mathbb{Z}_m^*$ generated by $2$.
\begin{lemma}
\label{cycleSize}
A Braun stream with cycle length $2^r m$ where $m$ is odd can be represented with a \share of size $2^{r+1} m \beta_m + 2^{r+1} - 1$.
%Furthermore, if every element in the cycle is distinct, it cannot be represented by a \share of any smaller size.
\end{lemma}
\begin{proof}
For a list {\tt x:xs} with length $n = 2^r m$, we must produce a \share bisimilar to {\tt bcycle x xs}:

\begin{alltt}
lcycle :: a -> [a] -> LStream a
lcycle x xs = 
  let ans = after x xs
      after y [] = Cons y ans
      after y (z:zs) = Cons y (after z zs)
  in ans

bcycle :: a -> [a] -> BS a
bcycle x xs = fromLStream (lcycle x xs)
\end{alltt}

Converting {\tt lcycle x xs} to a stream with {\tt fromLStream} produces 
\\
{\tt fmap lhead (iterate ltail (lcycle x xs))}

Also, using Theorem~\ref{iterateCorrect}, it is trivial to prove that {\tt iterate} is equivalent to

\begin{alltt}
iterateSlow :: (a -> a) -> a -> BS a
iterateSlow f x =
  let g y = f (f y)
      z = f x
  in BS x (iterateSlow g    z) 
          (iterateSlow g (f z))
\end{alltt}

Though this definition is much more intuitive, it is also much less efficient, as {\tt f} is applied to the same values repeatedly.
It shows that every location in the Braun stream $\iter f x$ is equivalent to $\iter f^{2^i}\ (f^j x)$ for some values of $i$ and $j$.

Applying this to {\tt bcycle x xs}, we see that every location in this Braun stream is equivalent to 
\\
{\tt fmap lhead (iterate (ltail}$^{2^i}${\tt ) (ltail}$^j\ ${\tt (lcycle x xs)))} 
\\
for some $i$ and $j$.
We denote the stream at such a location $\langle 2^i,j \rangle$, which we call its {\em address}.
The members of this pair are called the {\em increment} and {\em offset}, respectively.
On any cyclic {\tt LStream} {\tt ys} with cycle length $n$, {\tt ltail}$^k\ ${\tt ys} is bisimilar to {\tt ltail}$^l\ ${\tt ys} whenever $k \equiv l \mod n$.
Therefore, the streams $\langle i,j \rangle$ and $\langle k,l \rangle$ in the Braun stream {\tt bcycle x xs} are equivalent if $i \equiv k \mod n$ and $j \equiv l \mod n$.

This implies that there are at most $n^2$ distinct substreams of {\tt bcycle x xs}.
With appropriate sharing, then, a {\tt bcycle x xs} can be represented by a tree with at most $n^2$ internal nodes.
Out goal will be to show that it can be represented by a tree with $2^r m \beta_m + 2^r - 1$ internal nodes.
Since a tree with $q$ internal nodes has $q+1$ leaves, this will complete the lemma.
We proceed by induction on $r$. 

If $r$ is $0$, the cycle length is odd.
Since each address is $\langle 2^i,j \rangle$ for some $i, j$, by the definition of $\beta_m$, there are at most $\beta_m m$ distinct addresses $\mod m$.
Since every internal node that is not distinct from all other internal nodes can be replaced by a leaf, there are at most $\beta_m m$ internal nodes.

For the induction step, assume $r = s+1$ and any cycle of length $2^s m$ can be represented by a \share with $2^s m \beta_m + 2^s - 1$ internal nodes.
By our definition of {\tt iterateSlow}, it is clear that the left subtree of {\tt bcycle x xs} is {\tt fmap lhead (iterate (ltail}$^2${\tt ) (ltail (lcycle x xs)))}.
However, since {\tt ltail (lcycle x xs)} has even cycle length, {\tt (iterate (ltail}$^2${\tt ) (ltail (lcycle x xs)))} is cyclic with cycle length $n/2$;
it is simply every second element of {\tt (x:xs)}, cycled.
By the induction hypothesis, this Braun stream can be represented by a share with $2^s m \beta_m + 2^s - 1$ internal nodes.
A similar argument applies to the right subtree of {\tt bcycle x xs}.
Their number of internal nodes, including the internal node at the root of the {\tt Share}, is thus $1+2*(2^s m \beta_m + 2^s - 1) = 2^r m \beta_m + 2^r - 1$.
\qed
\end{proof}

In fact, this is the best we can do:

\begin{lemma}
A Braun stream {\tt bcycle x xs} with $n$ distinct elements and cycle length $n = 2^r m$ where $m$ is odd cannot be represented with a well-formed \share of size less than $2^{r+1} m \beta_m + 2^{r+1} - 1$.
\end{lemma}
\begin{proof}

Again we proceed by induction on $r$.
If $r$ is $0$, $n$ is odd.
We first show that every address $\langle 2^i,j \rangle$ is present in the Braun stream.
Since $n$ is odd, $2^i \mod n$ takes on every value in $\langle 2 \rangle$ (the subgroup of $\mathbb{Z}_n^*$ generated by $2$) infinitely often.
In particular, $2^{i+\beta_n} \equiv 2^i \mod n$.
Additionally, for $i > \log_2 n$, the offsets of the nodes at level $i$, when sorted, form a contiguous chain of natural numbers of length $2^i$.
Thus, every value of $\mathbb{Z}_n$ is congruent to the offset of some node at level $i$.

Therefore every address $\langle 2^i,j \rangle \in \langle 2 \rangle \times \mathbb{Z}_n$ corresponds to some location in the stream.
No pair of locations with distinct addresses is equivalent, since the cycle has $n$ distinct values.
%Additionally, since the \share is well-formed, such a pair of locations can be resolved to two distinct internal nodes.
This shows that the \share must have at least $|\langle 2 \rangle \times \mathbb{Z}_n| = \beta_m m$ internal nodes.
With the additional $\beta_m m + 1$ leaves, the entire tree is at least size $2 \beta_m m + 1$.

For the induction step, assume $r = s+1$ and no cycle with $2^s m$ distinct elements and cycle length $2^s m$ can be represented by a \share with fewer than $2^s m \beta_m + 2^s - 1$ internal nodes.
As before, the left subtree and right subtrees of {\tt bcycle x xs} are {\tt fmap lhead (iterate (ltail}$^2${\tt ) (ltail}$^{\{1,2\}}\ ${\tt (lcycle x xs)))}, respectively.
Again, since {\tt ltail (lcycle x xs)} has even cycle length, and the subtrees are cyclic with cycle length $n/2$.
The left tree is every second element of {\tt (x:xs)} (starting at the second element), cycled.
The left tree is every second element of {\tt (x:xs)} (starting at the third element and with {\tt x} appended at the end), cycled.
These lists are disjoint by assumption, so the left and right subtrees cannot have any inter-tree sharing.
Similarly, the root cannot share with either subtree, since it is cyclic with cycle length $n$ and contains values from both odd numbered and even numbered positions in {\tt (x:xs)}.

By our induction hypothesis, the left and right subtrees cannot be represented by {\tt Share}s with fewer than $2^s m \beta_m + 2^s - 1$ internal nodes.
The number of internal nodes, including the internal node at the root of the {\tt Share}, is thus $1+2*(2^s m \beta_m + 2^s - 1) = 2^r m \beta_m + 2^r - 1$.
With the leaves, this makes the tree at least size $2^{r+1} m \beta_m + 2^{r+1} - 1$
\qed
\end{proof}

When $m$ is $1$, $n$ is a power of $2$, and the cyclic Braun stream can be as small as $4n-1$.
When $\beta_n = n-1$, this tree can be as large as $2n(n-1)+1$.
A unsolved 90-year-old conjecture of Artin proposes that this occurs infinitely often \cite{artin}.

\subsection{Algorithm for Producing Minimal Cyclic Braun Streams}
\label{cycleAlgo}

It shall now be our goal to produce a well-formed \share that achieves this minimum size.
Though the process is straightforward, there are many details to track.
Haskell code for producing such a \share is in Fig.~\ref{cycleDetails}.

\begin{figure}
\begin{alltt}
floorlg2 x = case x `div` 2 of
               0 -> 0
               y -> 1 + floorlg2 y

increm real len = mod (2^(floorlg2 (1+real))) len

memo n (p,i) =
    case (compare p n, compare i (increm p n)) of
      (LT,EQ) -> Just p
      _ -> Nothing

type Fin x = (x,x,(x,x) -> Maybe x)
type Unk x a = (a,[a],x)
type Trak' x a = Either (Fin x) (Unk x a)
type Trak a = Trak' Integer a

action :: Trak a -> Trak a
action (Left (real,len,f)) =
    Left (real+1,len,
          case f (mod real len, increm real len) of
            Just _ -> f
            Nothing -> 
                (\(\backslash\)(p,i) ->
                 if (p == mod real len) && (i == increm real len)
                 then Just real
                 else f (p,i)))
action (Right (_,[],sofar)) = Left (1+sofar,1+sofar,memo (1+sofar))
action (Right (_,hed:tyl,sofar)) = Right (hed,tyl,1+sofar)

trunc :: [a] -> BS (Trak a) -> BraunRef a
trunc whole (BS (Left (real,len,f)) od ev) =
    case f (mod real len,increm real len) of
      Just bak -> Ref (order bak)
      Nothing -> Branch (whole `genericIndex` (mod real len)) 
                        (trunc whole od) 
                        (trunc whole ev)
trunc whole (BS (Right (hed,c,n)) od ev) =
    Branch hed (trunc whole od)
               (trunc whole ev)

smallCycle hed tyl =
  trunc (hed:tyl)
    (iterate action (Right (hed,tyl,0)))
\end{alltt}
\caption{Haskell code for producing a minimal \share the represents a cyclic stream.}
\label{cycleDetails}
\end{figure}

In order to build a minimal well-formed {\tt Share}, we must ensure that no internal node shares an address with location with a smaller location;
For any address $a$, only the first location with that address should be an internal node.
All other locations in the \share with the same address should be {\tt Ref}s.
%(Of course, there will be an infinite number of locations in an equivalent Braun stream with the same address; in a finite share some of these 

We do so by using the iterate algorithm designed in Sect.~\ref{iterSect}.
By proceeding through the locations in order, we can ensure that later locations do not share addresses with earlier ones.
To track earlier addresses, the iterated function {\tt action} acts on a partial map from addresses to locations of previously seen internal nodes.
If the address $a$ at location {\tt real} is already associated with a location, the map is not updated.
Otherwise, the map is updated so that $a$ is associated with {\tt real}.
To track the address as a function of the location, {\tt action} also acts on the location {\tt real} and the cycle length {\tt len}, which are converted to the address increment and offset by {\tt increm} and {\tt mod}.
These details are in the {\tt Left} branch of {\tt action}.

One additional detail we must deal with is that the algorithm must correctly deal with infinite input.
Furthermore, there is no Haskell function that can determine if a list is infinite.
The function {\tt action} therefore also acts on the input list itself, taking the tail at each iteration.
The details are in the {\tt Right} branch of {\tt action}
If the input is exhausted at location $sofar$, it has length $sofar+1$.
Once the input list is exhausted, {\tt action} initializes the partial map from addresses to locations.
Since no two locations $i,j <\ ${\tt sofar} have the same offset, none should be represented as a {\tt Ref}.

Applying iterate to {\tt action} and the input list produces a Braun stream with the output of action as its values.
The function {\tt trunc} maps those values to {\tt Share}s.
A {\tt Ref} is produced at location $i$ (with addresss $a$) if and only if {\tt action}$^i$ has consumed the entirety of the list input and the partial map from addresses to locations already maps $a$ to a location $j < i$.
All of the output of {\tt action} in the subtree at $i$ is discarded, but the addresses of all of these locations are already present in the subtree at location $j$.

If the input list is finite, {\tt action} and {\tt trunc} ensure that no two locations with the same address are both represented as internal nodes.
If the input list is not finite, {\tt action} never excapes the {\tt Right} branch, and {\tt trunc} produces an infinite {\tt Share}.

\section{Formalization in Coq}

Some of the details of the algorithms presented above have been formalized in the Coq proof assistant \cite{coq,website}.

One of the advantages of formalizing proofs of functional algorithms in Coq is that the data structures and algorithms can sometimes be directly embedded in Coq using its built-in syntax.
Coq natively supports inductive and coinductive types as well as recursive  and corecursive functions.
For the algorithms in this paper, direct embedding was only partially possible.

For instance, Coq requires functions producing values of coinductive types to be {\em productive}.
This condition as enforced in Coq is similar to the requirement that functions consuming values of inductive types be structurally recursive.
The iterate algorithm presented in Sect.~\ref{iterSect} is productive because of the way the two subtrees are interrelated, and is not productive in the eyes of Coq.
Instead of proving this function productive directly, it was rewritten as an inductive function, then proved terminating using some of Coq's more sophistacted methods for writing recursive functions, like well-founded induction.
The correctness of iterate is proved separately from this definition, in a module that simply assumes a definition matching the Haskell one given in Fig.~\ref{iterateCode}.

In some cases, direct embedding in Coq was both possible and even more usable that the Haskell code so embedded.
As noted in Subsect.~\ref{cycleAlgo}, Haskell lists may actually be streams.
Though this is sometimes a desired characteristic, as in the input to cycle, in some cases it does not reflect the actual desired meaning of the program.
For instance, Braun streams are only indexed by finite lists of boolean values.
Coq distinguishes between data structures that can be infinite (coinductive types) and those that must be finite (inductive types).
This difference helps Coq accurately model both intended uses, unlike Haskell.

\begin{comment}
how many lines?
how many generated lines?
hiccups:
* subtraction
* repeated function application not built-in (show equal to another formulation)
\end{comment}

\section{Conclusion}

Is there a data structure that provides terminating constant-time \verb|cons|?

Also good for finite Braun trees, because can get index i in time $i$, not $n+i$

Formalizing in a language with extraction

Formalizing time and space complexity

complete formalization

average case space complexity of cycle

\bibliographystyle{splncs}
\bibliography{braun}

\end{document}

% LocalWords:  Braun deque Coq subtree subtrees bijection superlinear
% LocalWords:  oddFromEven
